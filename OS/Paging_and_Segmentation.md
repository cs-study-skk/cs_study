# 페이징(Paging)과 세그멘테이션(Segmentation)

## 📌 페이징과 세그멘테이션
페이징과 세그멘테이션은 **메모리 관리 기법**이며 운영 체제가 프로그램의 **메모리 사용을 효율적으로 관리하고 보호하는 데 사용**된다.


<br>

## 📌 페이징(Paging)이란?
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/e0841739-aad4-45c5-a699-a908a60f6b0a)
- 메모리를 고정된 크기의 **블록(페이지)** 으로 나누는 기법.
- 이때 프로그램의 논리 주소 공간도 같은 크기의 **페이지** 로 나눠지고, 물리 메모리는 **페이지 프레임** 이라는 고정된 크기의 블록으로 나누어진다.

> #### ✔️ 페이지와 페이지 프레임
> 페이지(Page): 논리 주소 공간의 고정된 크기 블록 
> <br>
> 페이지 프레임 (Page Frame): 물리 주소 공간의 고정된 크기 블록 
> <br>
> 둘의 크기는 같음

<br>

### 1. 페이지 테이블 
- 각 논리 페이지가 물리 메모리의 어느 페이지 프레임에 매핑되는지를 나타내는 데이터 구조
- 페이지 테이블은 **논리 주소와 물리 주소의 변환을 지원** 함. CPU가 논리 주소를 물리 주소로 변환할 때 페이지 테이블을 찾음.
- 페이지 테이블은 여러 개의 엔트리로 구성되어 있음
- 각 엔트리는 하나의 논리 페이지에 해당
- 각 엔트리는 해당 논리 페이지가 매핑된 물리 페이지 프레임의 번호를 저장

<br>

### 2. 페이지 번호와 오프셋
- 논리 주소는 **페이지 번호**와 **오프셋** 두 부분으로 나뉨.
- **페이지 번호 (Page Number)**: 논리 주소와 상위 비트 부분. 페이지 테이블에서 해당 논리 페이지에 대응하는 페이지 프레임을 찾는 데 사용됨.
- **오프셋 (Offset)**: 논리 주소의 하위 비트 부분. 오프셋은 페이지 내에서 특정 데이터를 찾는 데 사용됨. 페이지 프레임 내 특정 위치를 지정.
  
<br>

### 3. 주소 변환 (논리 주소를 물리 주소로 변환)
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/9fb28ed4-31ac-4300-8edc-7395a45f6a5a)
- 논리 주소를 페이지 번호와 오프셋으로 나눈다. ex) 16 bit = 상위 8 bit (페이지 번호) + 하위 8 bit (오프셋)
- 페이지 번호를 사용하여 페이지 테이블을 조회한다. 페이지 테이블의 해당 엔트리에서 페이지 프레임 번호를 가지고 온다.
- 물리 페이지 프레임 번호에 오프셋을 더하여 최종 물리 주소를 계산한다. ex) 페이지 프레임 번호: 3 + 오프셋: 50 = 물리 주소는 3 번 페이지 프레임의 시작 주소 +50

<br>

### 4. 페이징의 장단점
- **장점: 외부 단편화 제거**
- 외부 단편화는 메모리 할당 및 해제 과정에서 작은 크기의 비연속적인 자유 메모리 블록들이 생겨서 큰 연속적인 메모리 블록을 할당할 수 없게 되는 현상
- 페이징에서는 메모리가 고정된 크기의 페이지와 페이지 프레임으로 나뉘어 있기 때문에 페이지 프레임 단위로 메모리를 관리함
- 즉, 모든 페이지와 페이지 프레임의 크기가 동일하므로 메모리 할당과 해제 시 외부 단편화가 발생하지 않음
- **단점: 내부 단편화**
- 내부 단편화는 할당된 메모리 블록 내에서 사용되지 않는 메모리 공간이 발생하는 현상
- 이는 고정된 크기의 블록을 사용하기 때문에 발생하는 현상으로 프로그램이 사용하는 실제 메모리 크기가 페이지 크기와 일치하지 않을 때 낭비된 공간으로 인해 내부 단편화가 발생
- 이는 페이징으로 해결할 수 없음
- **단점: 페이지 테이블 관리 오버헤드**
- **메모리 오버헤드**: 페이지 테이블 자체가 메모리를 차지한다. 논리 주소 공간이 클 경우 페이지 테이블도 커짐.
- **주소 변환 시간 오버헤드**: 주소 변환 과정에서도 페이지 테이블을 조회해야 함. 추가적인 메모리 접근이 필요하기 때문에 주소 변환 속도를 저하시킬 수 있음.
- **다단계 페이지 테이블**: 페이지 테이블이 커지면 여러 단계로 나누어 관리함. 그래서 각 단계에서 메모리를 추가로 접근해야 하므로 주소 변환이 더 복잡해지고 오래 걸릴 수 있음.

<br>

## 📌 세그멘테이션(Segmentation)이란?
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/117ba0fd-8985-4315-910c-d50921a1ef06)
- 메모리를 크기가 가변적인 논리적 단위(세그먼트)로 나누는 기법
- 각 세그먼트는 의미 있는 단위로 나눌 수 있고, **프로그램**은 이러한 세그먼트들로 구성됨
- 논리적 단위로는 method, procedure, function, object, variables, stack 등 함수단위로 나눌 수 있고 C컴파일러 관점에서는 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 단위로 구분지어 나눌 수 있음

> #### ✔️ 페이지와 페이지 프레임
> 세그먼트(Segment): 논리 주소 공간의 크기가 가변적인 블록
> <br>
> 세그먼트 테이블(Segment Table): 각 세그먼트가 물리 메모리의 어느 위치에 매핑되는지를 나타내는 테이블
> <br>

<br>

### 1. 세그먼트 번호와 오프셋
- 논리 주소는 세그먼트 번호와 세그먼트 내 오프셋으로 나뉜다.
- 세그먼트 번호는 세그먼트 테이블에서 해당 세그먼트의 시작 주소를 찾는 데 사용되고, 오프셋은 세그먼트 내의 정확한 위치를 나타낸다.

<br>

### 2. 주소 변환 (논리 주소를 물리 주소로 변환)
- CPU는 세그먼트 테이블을 참조해 논리 주소의 세그먼트 번호를 물리 주소의 시작 주소로 변환하고 오프셋을 더해 최종 물리 주소를 계산한다.
- 논리 주소는 세그먼트 번호와 세그먼트 내 오프셋으로 나뉨. ex) 논리 주소 16 bit = 상위 4 bit (세그먼트 번호) + 하위 12 bit (오프셋)
- 세그먼트 번호를 사용해 세그먼트 테이블을 조회.
- 세그먼트 테이블의 각 엔트리는 해당 세그먼트의 시작 주소와 길이를 저장함.
- 오프셋이 세그먼트의 길이 내에 있는지 확인.
- 만약 오프셋이 세그먼트 길이를 초과하면 잘못된 메모리 접근으로 처리되고 예외가 발생할 수 있음.
- 세그먼트의 시작 주소에 오프셋을 더해 최종 물리 주소를 계산. ex) 세그먼트 시작 주소 0x3000 + 오프셋 0xFA3 = 0x3FA3

<br>

### 3. 세그멘테이션의 장점: 논리적 단위로 메모리 분할
- 세그먼테이션은 **프로그램의 논리적 단위(예: 코드, 데이터, 스택)** 로 메모리를 분할할 수 있음.
- 이는 프로그램 구조와 일치시켜 코드 재사용, 모듈화, 유지 보수를 용이하게 함.

<br>

### 4. 세그멘테이션의 장점: 보호 및 공유 설정
- 각 세그먼트에 대해 개별적인 보호 설정이 가능.
- 예를 들어, 코드는 읽기 전용으로 설정하고, 데이터 세그먼트는 읽기/쓰기로 설정할 수 있음.
- 세그먼트 단위로 메모리를 공유할 수 있어 여러 프로세스가 같은 세그먼트 동시에 사용할 수 있음.

<br>

### 5. 세그멘테이션의 장점: 유연한 메모리 관리
- 세그먼트의 크기가 가변적이기 때문에 메모리를 유연하게 사용할 수 있음.
- 프로그램이 필요로 하는 메모리 크기에 따라 세그먼트 크기를 조정할 수 있음.

<br>

### 6. 세그멘테이션의 단점: 외부 단편화
- 세그먼트 크기가 가변적이기 때문에 **메모리 할당 및 해제 과정에서 외부 단편화가 발생** 할 수 있음.
- 외부 단편화는 **메모리의 비연속적인 자유 블록**이 생겨 큰 세그먼트를 할당하기 어려워질 수 있음.


<br>

### 7. 세그멘테이션의 단점: 메모리 관리 복잡성
- 세그먼트 크기가 가변적이기 때문에 **메모리 할당 및 해제**가 복잡해짐.
- 효율적인 메모리 관리를 위해 추가적인 메모리 관리 기법(압축, 가비지 컬렉션 등)이 필요할 수도 있음.


<br>

### 8. 세그멘테이션의 단점: 세그먼트 테이블 관리 오버 헤드
- 각 프로세스마다 세그먼트 테이블을 유지해야 하므로 메모리와 CPU 자원의 추가적인 오버헤드가 발생.
- 세그먼트 테이블의 크기와 관리가 복잡해질 수 있음.
  

    


참고: [페이징과 세그멘테이션](https://bellog.tistory.com/159)
[메모리 단편화, 페이징, 세그멘테이션](https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98)
