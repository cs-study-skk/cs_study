# 👉Memory 
프로그램이 실행되는 동안 필요한 정보를 저장하는 기억장치로 CPU가 직접 접근할 수 있는 기억 장치  
흔히 RAM(Random Access Memory)를 말하며 주기억장치 라고도 불린다. 

## 메모리의 종류
### RAM(Random Access Memory)
- 휘발성 메모리 : 전원 공급이 중단되면 저장된 데이터가 손실
- 읽기쓰기 가능
- ROM보다 속도가 빠름
> **SRAM(Static RAM)**<br>
> SRAM은 각 비트를 이중안정(bistable) 메모리 셀에 저장한다.<br>
> 이중안정 본성으로 인해 SRAM 메모리 셀은 자신의 값을 전원이 공급되는 한 유지한다.<br>
> SRAM은 DRAM과 달리 refresh가 필요 없고, 외란에 민감하지 않다.<br>
> 대신 DRAM보다 트랜지스터를 더 많이 사용하며 더 낮은 밀도를 가지고 더 비싸고 더 많은 전력을 소모한다.<br>
> * ex) 캐시메모리<br>

> **DRAM(Dynamic RAM)**<br>
> DRAM은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식으로 refresh해야 한다.<br>
> 또한 DRAM은 빛이나 전기적 잡음 같은 외란에 민감하다.<br>
> * ex) 메인메모리, 그래픽 시스템의 프레임 버퍼<br>

### ROM(Read Only Memory)
- 비휘발성 메모리 : 데이터가 반영구적
- 읽기전용
- RAM 보다 속도가 느림

## 캐시메모리(Cache)
- 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치(buffer memory)
- 처리 속도가 빠른 프로세서와 상대적으로 느린 메인 메모리의 속도 차이를 보완하기 위해 사용
- 프로세서는 가장 먼저 캐시를 확인 -> 주 기억장치를 접근하는 횟수가 줄어들어 컴퓨터의 처리속도가 향상

### CPU와 캐시의 상호작용
CPU에서 주소를 전달 → 캐시 기억장치에 존재하는지 확인<br>
캐시에 많이 활용되는 데이터가 있어야 비용을 줄일 수 있고 성능이 향상됨

- **Cache Hit**<br>
캐시에서 원하는 데이터를 찾음<br>
해당 명령어를 CPU로 전송 → 완료<br>

- **Cache Miss**<br>
해당 데이터가 캐시에 없어 주메모리로 가서 데이터를 찾음<br>
명령어를 갖고 주기억장치로 접근 → 해당 명령어를 가진 데이터 인출 → 해당 명령어 데이터를 캐시에 저장 → 해당 명령어를 CPU로 전송 → 완료<br>

### 지역성
캐시 접근 시 정보를 균일하게 액세스하는 것이 아니라 특정 부분을 집중적으로 참조 
- **시간 지역성**<br>
  특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높다. <br>
  Ex) For, while 반복문에 사용되는 데이터는 참조 가능성이 높으므로 다시 저장한다.<br>
  
- **공간 지역성**<br>
  액세스된 기억장소와 인접한 기억장소가 액세스될 가능성이 높다. <br>
  Ex) 배열에서 같은 연속 접근시, 참조된 데이터 근처에 있는 데이터가 참조 가능성이 높으므로 저장한다.


## 메모리 계층구조
![image](https://github.com/cs-study-skk/cs_study/assets/77658108/b3b19f54-a23c-48ef-a6f1-a7694e03a399)
- 레지스터와 캐시는 CPU 내부에 존재 

## 메모리 공간
![image](https://github.com/cs-study-skk/cs_study/assets/77658108/cca83667-08f2-435b-9483-0840cfd8088c)
- **코드**<br>
  실행할 프로그램의 코드가 저장되는 텍스트 영역이다. CPU는 코드영역에서 저장된 명령어를 하나씩 가져가서 처리한다.
- **데이터** <br>
  전역변수와 정적변수가 이해 해당된다. 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸된다.
- **스택**<br>
  스택영역은 함수의 호출과 관계되는 지역변수와 매개변수, 메소드가 저장되는 영역이다.<br>
  함수의 호출과 함께 할당되며, 함수의 호출이 종료될때 해제된다.<br>
  높은 주소에서 낮은 주소의 방향으로 할당<br>
- **힙**<br>
  힙 영역은 사용자가 직접 관리할 수 있는 메모리 영역이다.<br>
  힙 영역은 사용자에 의해 메모리공간이 동적으로 할당되고 해제된다.<br>
  낮은 주소에서 높은주소 방향으로 할당 <br>



# 👉MMU (Memory Management Unit, 메모리 관리 장치)
![image](https://github.com/cs-study-skk/cs_study/assets/77658108/7967ec36-1c7e-47bb-8edb-b72917432239)
- 논리 주소를 물리 주소로 변환해 준다.
- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해 주는 하드웨어
- 메모리의 공간이 한정적이기 때문에, 사용자에게 더 많은 메모리를 제공하기 위해 *'가상 주소'라는 개념이 등장
- 가상 주소에서 실제 데이터가 담겨 있는 곳에 접근하기 위해선 빠른 주소 변환이 필요한데, 이를 MMU가 도와준다.

> **가상메모리(Virtual Memory)**<br>
> 컴퓨터가 실제로 이용가능한 메모리 자원을 추상화하여 사용자들에게 매우 큰 메모리로 보이게 만드는 것  
> 메모리관리장치(MMU)에 의해 가상주소가 실제주소로 변환되어 사용자가 실제 주소를 의식하지 않고 프로그램 구축이 가능<br>
> 가상 메모리는 가상주소와 실제주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 '페이지 테이블'로 관리. <br>

## MMU의 메모리 보호
프로세스는 독립적인 메모리 공간을 가져야 되고, 자신의 공간만 접근해야 한다. <br>
따라서 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호함

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F5Lgut%2FbtquNvKMRwH%2FJOqzcmz8wiXf0Kv7okfGzK%2Fimg.png" width="500">

- **base 레지스터** : 메모리상의 프로세스 시작주소를 물리 주소로 저장
- **limit 레지스터** : 논리적 주소의 최댓값으로 프로세스의 사이즈를 저장

프로세스의 접근 가능한 합법적인 메모리 영역(x)
```
base <= x < base+limit
```

## 프로세스 영역의 할당
### Contiguous allocation 
각각의 프로세스를 메모리의 연속적인 공간에 할당시키는 방법

#### - Fixed partition allocation(고정 분할)
- 메모리의 공간을 고정된 크기로 나누는 방식
- 분할의 크기는 모두 동일하거나 다를 수 있고 동시에 메모리에 load되는 프로세스 개수가 고정되며 수행 
- 가능한 프로세서의 크기가 제한된다.
 
#### - Variable partition allocation(가변 분할)
- 프로세스의 크기를 고려해서 할당하는 방식
- 분할의 크기나 개수가 동적으로 변한다.
- 기술적 관리 기법이 필요하다.

### Noncontiguous allocation
- 하나의 프로세스를 메모리의 여러 영역에 분산하여 할당하는 방법
- 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당
- Paging, Segmentation, Paged Segmentation 기법 사용


