# 시스템 콜 (System Call)

## 📌 시스템 콜이란?
- **운영 체제(OS)가 제공하는 서비스를 사용**하기 위한 **프로그래밍 인터페이스**이다.
- 운영 체제는 **커널 모드(Kernel Mode)**와 **사용자 모드(User Mode)**로 나누어서 구동된다.
- 이때 운영 체제에서 파일을 읽어 오거나, 파일을 쓰거나, 화면에 출력하는 등 많은 부분을 **커널 모드에서 사용**한다.
- 즉, **시스템 콜**이란 **커널 영역의 기능을 사용자 모드가 사용 가능하게** 해 주는 것이다.
- 또한 **프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게** 해 준다.
- **시스템 콜**은 **내부 인터럽트**의 한 종류이며 **사용자 모드에서 커널 모드로 전환하기 위해 필요한 인터페이스**이다.

<br>

> **커널(Kernel)이란?**
> <br> **운영 체제의 핵심 부분**으로 **하드웨어와 소프트웨어 간의 인터페이스를 제공하는 역할**을 한다.
> <br> 또한 **컴퓨터 자원들을 관리하는 역할**을 한다.
> <br> 다만 커널은 항상 컴퓨터 자원들을 바라만 보고 있기에 사용자와의 상호작용은 지원하지 않는다.
> <br> 쉘(shell)과 같은 프로그램들을 통해 사용자와 직접적인 상호작용이 가능해진다.

<br>

## 📌 CPU 모드
- 운영 체제가 CPU 모드를 사용하는 이유는 **시스템을 보호하기 위해서**이다.
- 사용자가 권한 없이 시스템 내부 데이터를 만질 수 없게 함으로써 내부 데이터에 쉽게 접근해 의도치 않게 혹은 악의적으로 시스템을 해칠 수 있는 경우를 대비하는 것이다.
- 이를 **이중 동작 모드**라고 부르며, 이를 실행하여 **유저 애플리케이션이 함부로 시스템 자원에 접근할 수 없게 한다.**
- **CPU 모드**에는 두 가지 모드가 있는데 **Mode Bit**로 모드를 구분한다.
- 0은 **커널 모드**, 1은 **사용자 모드**이다.

![image](https://github.com/cs-study-skk/cs_study/assets/39427152/778e22e9-5aca-4628-a39d-fb2171fabdc0)

<br>

**사용자 모드 (User Mode)**
- 사용자 모드에서는 **사용자 애플리케이션 코드가 실행**된다.
- 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 **하드웨어에 접근할 수 없다.**
- **하드웨어에 직접 접근할 수 없기 때문에** 하드웨어와의 상호 작용을 위해 **운영 체제의 지원이 필요**하다.
- 그렇기 때문에 이를 **운영 체제에게 수행하도록 요청하는 시스템 콜**을 사용해야 한다.
- 또한, 각각의 사용자 애플리케이션 스레드는 **고유한 사용자 모드 스택**을 가지고 있다.
- **사용자 모드 스택**은 스레드가 실행되는 동안 사용되며 **스레드 간의 독립성과 보호를 제공**한다.

<br>

**커널 모드 (Kernel Mode)**
- 운영 체제가 **CPU를 사용하는 모드**이다.
- 커널 모드로 전환이 일어나면 **운영 체제는 하드웨어를 제어하는 명령어를 실행**한다.
- 운영 체제가 하드웨어를 제어하고 관리하는 명령어를 **특권 명령어(Privileged Instructions)**라고 부른다.


<br>

## 📌 시스템 콜의 유형
시스템 콜은 크게 6 가지 유형으로 분류 가능하다. 또한 명령어들은 **UNIX**에서 사용되는 명령어이다.

#### 1. 프로세스 제어 (Process Control)
- 끝내기(exit), 중지 (abort)
- 적재(load), 실행(execute)
- 프로세스 생성(create process) - fork
- 프로세스 속성 획득과 속성 설정
- 시간 대기 (wait time)
- 사건 대기 (wait event)
- 사건을 알림 (signal event)
- 메모리 할당 및 해제

#### 2. 파일 조작 (File Manipulation)
- 파일 생성 / 삭제 (create, delete)
- 열기 / 닫기 / 읽기 / 쓰기 (open, close, read, wirte)
- 위치 변경 (reposition)
- 파일 속성 획득 및 설정 (get file attribute, set file attribute)

#### 3. 장치 관리 (Device Manipulation)
- 하드웨어의 제어와 상태 정보를 얻음 (ioctl)
- 장치를 요구(request device), 장치를 방출 (relese device)
- 읽기 (read), 쓰기(write), 위치 변경
- 장치 속성 획득 및 설정
- 장치의 논리적 부착 및 분리

#### 4. 정보 유지 (Information Maintenance)
- getpid(), alarm(), sleep()
- 시간과 날짜의 설정과 획득 (time)
- 시스템 데이터의 설정과 획득 (date)
- 프로세스 파일, 장치 속성의 획득 및 설정

#### 5. 통신 (Communication)
- pipe(), shm_open(), mmap()
- 통신 연결의 생성, 제거
- 메시지의 송신, 수신
- 상태 정보 전달
- 원격 장치의 부착 및 분리

#### 6. 보호 (Protection)
- chmod(): 파일 및 디렉토리의 권한 및 소유자 정보를 변경함
- umask(): 새로 생성되는 파일의 기본 권한을 설정
- chown(): 파일이나 디렉토리의 소유자 및 그룹을 변경하는 데 사용


<br>

## 📌 시스템 콜 작동 방식
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/1abf55f2-f875-4955-9087-53100917be37)
1. **라이브러리 함수를 호출**한다.
2. 라이브러리 함수 내부에서 **시스템 콜을 호출**한다.
3. 해당 시스템 콜의 **인덱스를 CPU 레지스터에 저장**한다.
4. **0x80 인터럽트를 발생**시킨다. -> **커널 모드로 전환** 발생
5. IDT(Interrupt Descriptor Table)를 참조하여 **system_call()을 호출**한다.
6. 이때 3에서 저장된 인덱스를 **system_call() 함수 내에 전달**한다.
7. sys_call_table을 참조해 **해당 인덱스에 맞는 기능(sys_write)을 호출**한다.
8. 수행이 모두 끝나면 **사용자 모드로 전환**된다.


<br>
<br>



참고 블로그: 
[참고](https://luckyyowu.tistory.com/133)
[참고](https://hojunking.tistory.com/48)
[참고](https://didu-story.tistory.com/311)
