# 스케줄링 알고리즘

## 📌 선점형 알고리즘
- 현재 실행 중인 프로세스가 강제로 CPU를 놓고 다른 프로세스에게 CPU를 넘길 수 있도록 하는 방식의 알고리즘
- 프로세스가 일정한 시간 동안만 실행되며 그 이후에는 운영체제가 인터럽트를 걸어 다른 프로세스를 실행
- 즉 하나의 프로세스가 다른 프로세스 대신에 프로세서(CPU)를 차지할 수 있음

<br>

### 1. RR (Round Robin Scheduling)
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/8ae05da2-dee5-4efe-85a9-2765ef7cd1eb)
- 각 프로세스가 CPU 시간을 공평하게 배분받도록 설계된 방식
- 시분할 시스템에서 주로 사용되며 프로세스 간의 공정성을 보장함
- 타임 슬라이스 (Time Slice) 또는 타임 퀀텀 (Time Quantum)이라고 불리는 각 프로세스가 CPU를 사용할 수 있는 최대 시간이 존재하는데 이 시간이 지나면 다른 프로세스가 CPU를 사용하도록 강제 스위칭을 함
- 프로세스 큐 (Process Queue): 준비 상태에 있는 모든 프로세스가 FIFO 방식으로 관리되는 큐에 저장됨

<br>

#### 동작 과정
1) 모든 준비 상태의 프로세스가 큐에 삽입됨
2) 스케줄러는 큐의 맨앞에 있는 프로세스를 선택해 CPU를 할당함
3) 프로세스가 타임 슬라이스를 모두 사용하거나 프로세스가 자발적으로 종료되거나 블록 되면 CPU가 스케줄러에 반환됨
4) 이 과정을 반복해 모든 프로세스가 CPU 시간을 공평하게 배분받도록 함

<br>

#### 장점
1) 모든 프로세스가 동일한 기회를 부여받아 공평하게 CPU를 사용할 수 있음
2) 시스템 응답 시간이 예측 가능
3) 긴 작업이 시스템을 독점하는 현상을 막을 수 있음
4) 비교적 알고리즘이 간단해 구현에 용이

<br>

#### 단점
1) 빈번한 문맥 교환으로 시스템 오버 헤드 증가
2) 타임 슬라이스가 너무 짧으면 오버 헤드가 증가하고, 너무 길면 반응 속도가 저하될 수 있음
3) 실시간 처리가 중요할 경우 최적의 선택이 아닐 수 있음

<br>

### 2. SRTF, SRT (Shortest Remaining Time First)
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/d1b22af0-fcb4-4827-844d-679d422aded7)
- 가장 남은 실행 시간이 짧은 프로세스를 우선적으로 실행
- 프로세스가 도착할 때마다 현재 실행 중인 프로세스와 비교하여 남은 실행 시간이 더 짧은 프로세스가 있다면 중지하고 새로운 프로세스를 실행함
- **선점형 알고리즘**이기 때문에 현재 실행 중인 프로세스가 도중에 중단될 수 없음
- **남은 실행 시간** = 프로세스 총 실행 시간 - 현재까지 실행된 시간

<br>

#### 동작 과정
1) 새로운 프로세스가 도착하면 현재 실행 중인 프로세스의 남은 실행 시간과 도착한 프로세스의 남은 실행 시간을 비교
2) 남은 실행 시간이 더 짧은 프로세스를 선택
3) 만약 도착한 프로세스의 남은 실행 시간이 현재 실행 중인 프로세스보다 짧으면 현재 실행 중인 프로세스를 중단하고 새로운 프로세스를 실행
4) 모든 프로세스가 완료될 때까지 반복 

<br>

#### 장점
1) 평균 대기 시간을 최소화해 효율적인 CPU 사용을 보장
2) 짧은 작업이 빨리 완료되므로 시스템의 응답 속도가 향상

<br>

#### 단점
1) 빈번한 선점을 으로 인해 컨택스트 스위칭 오버헤드가 발생할 수 있음
2) 긴 실행 시간을 가진 프로세스가 계속해서 대기 상태로 밀려날 수 있음 -> 기아 현상 발생 가능성 있음
3) 남은 실행 시간을 지속적으로 추적하고 비교해야 해서 구현이 복잡함

<br>

## 📌 비선점형 알고리즘
- 한 번 CPU가 할당받은 프로세스가 자발적으로 CPU를 놓을 때까지 실행을 계속하는 스케줄링 방식
- 현재 실행 중인 프로세스가 종료되거나 I/O 작업을 위해 블록 상태가 되거나 다른 이유로 스스로 CPU를 반환할 때까지 다른 프로세스가 CPU를 차지할 수 없음

### 1. FCFS (First Come First Served)
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/6aa76d3c-086a-48bd-955b-1e0bbd16c51d)
- 비선점형 스케줄링 알고리즘의 한 종류
- 가장 먼저 도착한 프로세스가 먼저 CPU를 할당받는 방식
- 프로세스 도착 순서에 따라 CPU를 할당하는 가장 단순힌 방식의 스케줄링
- 한 번 CPU를 할당받은 프로세스는 자신이 완료될 때까지 CPU를 점유하며 다른 프로세스는 대기 상태
- FIFO(선입선출) 방식으로 도착한 순서대로 프로세스 처리

<br>

#### 동작 과정
1) 준비 큐에 도착한 프로세스가 순서대로 저장
2) 준비 큐의 맨앞에 있는 프로세스에게 CPU를 할당
3) 할당된 프로세스는 완료될 때까지 CPU를 점유
4) 프로세스가 완료되면 CPU를 반환하고, 준비 큐의 다음 프로세스가 CPU를 할당받음

<br>

#### 장점
1) 구현이 매우 간단하고 이해하기 쉬움
2) CPU를 한 번 할당받은 프로세스는 완료될 때까지 중단되지 않으며 컨택스트 스위칭 오버헤드가 없음
3) 프로세스가 도착한 순서대로 처리되므로 공정성이 보장됨

<br>

#### 단점
1) 긴 프로세스가 먼저 도착하면 뒤따라 오는 짧은 프로세스들이 오랜 시간 대기해야 하는 문제 발생
2) 짧은 작업이 긴 작업 뒤에 계속 밀려 대기 시간이 길어질 수 있음 -> 기아 현상 발생
3) 대기 중인 프로세스의 평균 대기 시간이 길어져 시스템의 응답성이 저하될 수 있음
4) CPU 이용률이 비효율적일 수 있으며 긴 프로세스가 전체 시스템의 처리 속도를 저하시킬 수 있음

<br>

### 2. SJF (Shortest Jop First)
- 실행 시간이 가장 짧은 프로세스가 먼저 CPU를 할당받아 실행되는 방식
- 평균 대기 시간을 최소화할 수 있어 효율적인 CPU 사용이 가능하게 함
- 프로세스의 예상 실행 시간을 기준으로 스케줄링하며 실행 시간이 짧은 프로세스가 먼저 실행됨
- 한 번 CPU를 할당받은 프로세스는 완료될 때까지 실행을 계속함
- 이 알고리즘의 선점형 방식이 **SRTF**

<br>

#### 동작 과정
1) 새로운 프로세스가 도착하면 준비 큐에 삽입됨
2) 준비 큐에 있는 모든 프로세스의 예상 실행 시간을 비교
3) 실행 시간이 가장 짧은 프로세스를 선택해 CPU를 할당함
4) 선택된 프로세스가 완료될 때까지 계속 실행하며 모든 프로세스가 완료될 때까지 반복

<br>

#### 장점
1) 평균 대기 시간을 최소화할 수 있어 전체 시스템 성능이 향상
2) 실행 시간이 짧은 작업을 우선 처리하여 빠르게 완료되는 작업이 많아짐

<br>

#### 단점
1) 프로세스의 실행 시간을 미리 정확히 예측하기 어려울 수 있음
2) 실행 시간이 긴 프로세스는 계속해서 대기 상태로 남아 기아 상태에 빠질 수 있음
3) 실시간 처리가 필요한 환경에서 비효율적일 수 있음

<br>


## 📌 둘 다 가능
### 1. Priority Scheduling
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/d9eeb53e-9ad8-4455-970b-7fc5b60ed555)
- 각 프로세스의 우선 순위를 부여하고, 이 우선 순위에 따라 CPU를 할당하는 방식
- 우선순위가 높은 프로세스가 먼저 실행이 됨
- 우선순위는 내부적 사유(CPU 사용 시간, 메모리 요구량) 또는 외부적 사유(사용자 지정)에 의해 결정될 수 있음
- 이 알고리즘은 선점형 방식과 비선점형 방식을 둘 다 사용 가능하며 선점형일 경우 우선순위가 높은 프로세스가 도착하면 현재 실행 중인 프로세스를 중단하고 CPU를 할당


<br>

#### 동작 과정
1) 새로운 프로세스가 도착하면 준비 큐에 삽입됨
2) 준비 큐에 있는 모든 프로세스의 우선순위를 비교
3) 가장 높은 우선순위를 가진 프로세스를 선택해 CPU를 할당
4) 선택된 프로세스가 완료될 때까지 또는 선점될 때까지 실행을 계속함

<br>

#### 장점
1) 우선순위가 높은 작업을 먼저 처리할 수 있어 긴급한 작업이 빠르게 완료
2) 우선순위를 통해 다양한 중요도의 작업을 효과적으로 처리할 수 있음

<br>

#### 단점
1) 우선순위가 낮은 프로세스는 높은 우선순위의 프로세스들 때문에 계속 대기 상태에 놓여 기아 상태에 빠질 수 있음
2) 낮은 우선순위의 프로세스가 높은 우선순위의 프로세스에 의해 계속 선점될 때 우선순위 역전이 발생하며 시스템 성능에 부정적인 영향을 미칠 수 있음
3) 우선순위 부여와 관리가 복잡할 수 있고, 동적 우선순위의 경우 더 복잡함

<br>



<br>
