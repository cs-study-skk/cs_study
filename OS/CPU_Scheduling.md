# CPU 스케줄링

## 📌 CPU 스케줄링이란?
- CPU의 이용률을 극대화하기 위해서는 멀티 프로그래밍이 필요하지만 만약 CPU 코어가 하나라면 한 번에 하나의 프로세스만 실행이 가능하다.
- 그렇기 때문에 운영체제의 CPU 스케줄러는 **준비 상태의 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정**하게 된다.
- 즉, CPU 스케줄링은 **언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업**이라고 볼 수 있다.
- CPU 스케줄링은 규모에 따라 **장기, 중기 단기 스케줄링**으로 구분된다.

<br>

> ✍ CPU 스케줄링의 목적
> - 모든 프로세스가 CPU 자원을 공정하게 이용할 수 있게 하기 위해 CPU 시간을 공평하게 받아 사용할 수 있도록 해 준다. (공평성)
> - CPU가 항상 활동하도록 해서 시스템 자원을 최대한으로 활용한다. 즉, 시스템 자원이 쉬는 시간이 없어야 한다. (자원 이용률 최적화)
> - 프로세스가 요청한 작업을 시작하는 데 걸리는 시간을 최소화해 사용자가 프로그램 실행 시 빠르게 응답을 받을 수 있도록 한다. (응답 시간 최소화)
> - 중요 프로세스들에게 우선권을 주어야 하며, 프로세스가 증가해도 안정적으로 들어가게 한다 .(안정성)
> - 시스템 자원이 늘어나는 경우 혜택이 시스템 반영되어야 한다. (확장성)
> - 특정 프로세스 작업이 무한정 연기되어 있으면 안 된다.

<br>

## 📌 선점 및 비선점 스케줄링 (Preemptive and Nonpreemptive Scheduling)
> 1. 실행(running) 상태에서 대기(waiting) 상태로 전환(switching)될 때 ( ex : I/O 발생 )
> 2. 실행(running) 상태에서 준비(ready) 상태로 전환(switching)될 때 ( ex : 인터럽트 발생 )
> 3. 대기(waiting) 상태에서 준비(ready) 상태로 전환(switching)될 때 ( ex : I/O 완료 시 )
> 4. 종료(Terminated)될 때

CPU 스케줄러는 **프로세스들이 위의 네 가지 상황**에 있을 때 스케줄링을 결정하게 된다.
1 번과 4 번의 케이스는 **비선점형 스케줄링** 나머지 모든 스케줄링은 **선점형 스케줄**이라고 한다.

<br>

### 선점형 스케줄링
- 운영체제가 필요하다 판단하면 **실행 상태에 있는 프로세스의 작업을 중단**하고, **새로운 작업을 시작**한다.
- Timeout 상황, I/O Interrupt, System call 등이 발생한 경우 **현재 실행 상태에 있는 프로세스의 CPU를 강제로 회수하고 다른 프로세스에게 CPU를 할당**해 줄 수 있는 스케줄링 방식.
- CPU 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하다.
- 잦은 문맥 교환(Context Switching)으로 오버 헤드가 발생할 수 있다.
- 하지만 하나의 프로세스가 CPU를 독점한다는 것은 **동시에 여러 작업을 할 수 없다**의 의미기 때문에 대부분의 저수준 스케줄러(I/O Interrupt, System call 등)는 선점형 스케줄링 방식을 사용한다.

<br>

### 비선점형 스케줄링
- **어떤 프로세스가 실행 상태에 들어가면 그 프로세스가 끝나거나 CPU를 자진 반납하는 경우가 아니면 계속 실행**되는 스케줄링 방식.
- 문맥 교환(Context Switching)에 대한 오버 헤드가 없고, 스케줄러가 할 일도 적어져 **효율적**이다.
- 하지만 **전체 시스템의 처리율이 떨어지며 프로세스의 배치에 따라 효율성 차이가 클 수 있다.**


<br>

## 📌 CPU 스케줄링 평가 기준
CPU 스케줄링 알고리즘의 성능을 비교하고 시스템의 효율성을 평가하는 데 사용되는 평가 기준.
이러한 기준들은 상충될 수 있으며 그렇기 때문에 CPU 스케줄링 알고리즘을 선택할 때 이런 상충 관계를 고려해 적절한 평가 기준을 정하고, 각각의 기준에 따라 알고리즘 성능을 평가해야 함.

#### 1. CPU 이용률 (CPU utilization)  
- CPU가 놀지 않고 항상 활동하는 시간의 비율
- 높은 CPU 이용률은 시스템 자원을 효율적으로 사용한다는 의미와 같음
- 프로세서를 실행 상태로 항상 유지하려고 해야 함

#### 2. 처리율 (Throughput)
- 시간당 처리한 작업의 비율
- 단위 시간당 완료되는 작업 수가 많도록 해야 함

#### 3. 반환 시간 (Turnaround Time) 
- 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
- 반환 시간이 짧을수록 프로세스들이 빠르게 완료되는 것을 의미하며 시스템의 처리량과 효율성을 나타내는 중요한 지표
- 작업이 준비 큐(ready queue)에서 기다린 시간부터 CPU에서 실행된 시간, I/O 작업 시간의 합

#### 4. 대기시간 (Waiting Time)
- 대기열에 들어와 CPU를 할당받기 까지 기다린 시간
- 준비 큐에서 기다린 시간의 총합

#### 5. 반응시간 (Response Time)
- 대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간
- 대기 시간과 비슷하지만 다른 점은, 대기 시간은 준비 큐에서 기다린 모든 시간을 합친 것이지만 반응 시간은 CPU를 할당받은 최초의 순간까지 기다린 시간 한번만을 측정
- 사용자가 프로그램 실행에 대한 빠른 응답을 기대할 때 중요한 기준

#### 6. 종료 시간 (Completion Time)
- 프로세스가 시작되어 완료될 때까지의 전체 시간

#### 7. 우선순위 (Priority)
- 프로세스에 부여된 우선순위가 높을수록 해당 프로세스에게 CPU 시간이 더 할당되는 것을 의미
- 중요한 작업이나 긴급한 작업에 대한 처리를 보장하는 데 사용됨

<br>

## 📌 CPU 스케줄링 우선순위
![image](https://github.com/cs-study-skk/cs_study/assets/39427152/0697975b-d675-4a5c-81d7-122214db0538)

<br>

> ✔️ 전면 프로세스와 후면 프로세스
> - 전면 프로세스는 GUI를 사용하는 OS에서 화면 맨 앞에 놓인 프로세스
> - 전면 프로세스는 입출력을 사용하는 프로세스이며 사용자와 상호작용이 가능
> - 그렇기 때문에 전면 프로세스는 사용자의 입력에 빠르게 응답해야만 함
> - 예를 들면 웹 브라우저, 텍스트 편집기, 게임 등
> - 후면 프로세스는 사용자와 상호작용이 없는 프로세스
> - 사용자의 입력을 기다리지 않고 보통 시스템 리소스를 활용해 백그라운드에서 동작
> - 주로 시간이 오래 걸리거나 사용자의 직접적 관여가 필요하지 않은 작업을 수행
> - 예를 들면 파일 다운로드, 압축 풀기, 데이터베이스 작업 등
