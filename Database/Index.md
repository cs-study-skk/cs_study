# 인덱스(Index)

MySQL에서는 인덱싱이나 검색 방식에 따라 데이터베이스 엔진(스토리지 엔진)을 선택해야 할 수도 있기 떄문에 인덱스에 대한 기본 지식은 중요하며, 쿼리 튜닝의 기본이 된다.

> **MySQL DB의 스토리지 엔진이란?**
>
> DB에서 데이터를 어떠한 방식으로 저장하고 접근할 것인지에 대한 기능을 제공한다.
>
> 스토리지 엔진의 특성에 따라 데이터 접근이 얼마나 빠른지, 얼마나 안정적인지, 트랜잭션 등의 기능을 제공하는지 등의 차이점이 발생한다.
>
> <u>MyISAM</u>, InnoDB, Cluster, Archive, Federated 등이 있다.



## 📎 인덱스란?

책을 예시로 들자면, 책의 마지막에 있는 찾아보기/색인이 `인덱스`, 책의 내용은 `데이터 파일`이다.

칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value pair)으로 인덱스를 만들어 둔다.

`SortedList`는 DBMS의 인덱스와 같은 자료구조다. (데이터 파일은 `ArrayList` 자료구조)

- `SortedList`는 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조
- DBMS의 `인덱스`도 특정 컬럼의 값을 기준으로 정렬된 상태로 유지





### 인덱스가 동작하는 과정

인덱스가 있다면, `SELECT` 쿼리문에서 `Index 생성 컬럼을 WHERE 조건으로 걸기`나 `Index 컬럼으로 Order By에 의한 정렬을 적용`하면, 옵티마이저가 이를 판단하여 생성된 인덱스를 적용해 select 문을 실행한다.



> **옵티마이저(Optimizer)**
>
> 데이터베이스 옵티마이저는 SQL 쿼리의 실행 계획을 수립하는 역할을 한다. 쿼리를 실행하기 위해 데이터베이스가 사용할 구체적인 절차와 순서를 의미하는데, 인덱스는 옵티마이저가 효율적인 실행 계획을 수립하는 데 중요한 요소 중 하나다.

![image](https://github.com/user-attachments/assets/af486587-d6d3-484d-a28f-810a5f0c6d2b)


- 인덱스 생성

```sql
CREATE INDEX idx_employee_id ON employees(employee_id);
```

- WHERE 절에 인덱스 컬럼 사용

``````sql
SELECT * FROM employees WHERE employee_id = 123;
``````

- ORDER BY 절에 인덱스 컬럼 사용

```sql
SELECT * FROM employees ORDER BY employee_id;
```



인덱스를 사용함으로써 데이터베이스가 테이블의 모든 행을 검색하는 풀 테이블 스캔(Full Table Scan)을 수행하지 않고, 인덱스를 통해 필요한 데이터에 빠르게 접근할 수 있게 된다.



> **Full Table Scan**
>
> 조건에 맞는 데이터를 찾아내기 위해 테이블의 레코드를 처음부터 끝까지 다 읽으면서 검색 조건과 맞는지를 비교하는 것.
>
> 가장 느린 Scanning 방법이며, 전체 데이터를 읽는 과정에서 많은 자원을 소모하게 된다.


![image (1)](https://github.com/user-attachments/assets/ab1f9027-6d59-4c5c-ac50-6517449a9eea)


인덱스 스캔에서 특정 시점까지는 Full Table Scan이 더 빠를 수 있다.

- Index를 통한 검색을 B+-Tree에서 리프 노드까지 찾아 내려가서 해당 데이터를 찾기 위해 디스크로 접근하는 과정을 거치는데, Full Table Scan은 B+Tree를 거치지 않고 바로 디스크에서 데이터를 읽어오기 때문이다
- 떄문에 데이터의 양이 많지 않거나, Index가 효율적으로 설정되어 있지 않는 경우는 오히려 Table Full Scan이 더 빠르다





### 인덱스의 장점과 단점

`SortedList`자료구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만 이미 정렬이 되어 있어서 아주 빨리 원하는 값을 찾아올 수 있다.

DBMS의 ` 인덱스`도 마찬가지다. 인덱스가 많은 테이블에서는 당연히 `INSERT`, `UPDATE`, `DELETE`의 처리가 늦지만, 이미 정렬되어 있어 `SELECT` , 즉 조회는 아주 빠르다.



- 장점
  - 검색 대상 레코드의 범위를 줄여 검색 속도를 빠르게 할 수 있다. (조회 성능 향상)
  - 중복 데이터를 방지하거나 특정 컬럼의 유일성(Unique)을 보장할 수 있다.
  - ORDER BY 절과 GROUP BY 절, WHERE 절 등이 사용되는 작업이 더욱 효율적으로 처리된다.
  - 전반적인 시스템의 부하를 줄일 수 있다.

- 단점

  - 인덱스 생성에 따른 추가적인 저장 공간이 필요하다. (DB의 약 10%에 해당하는 저장 공간 필요; 인덱스 사용 시 해당 정보를 담은 MYI 파일 생성)

  - CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다. 즉, 데이터 갱신보다는 조회에 주로 사용되는 컬럼에 인덱스를 생성하는 것이 유리하다.

    - CREATE(INSERT) : 새로운 데이터에 대한 인덱스 추가
    - UPDATE : 기존 인덱스를 제거하고, 갱신된 데이터에 대해 인덱스를 추가
    - DELETE : 삭제하는 데이터의 인덱스를 제거

  - 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.

  - 인덱스 생성 시간이 오래 걸릴 수 있다.

  - 인덱스를 남발하거나 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생될 수 있다.

    

📌 **결론적으로 DBMS에서 `인덱스`는 데이터의 저장 성능을 희생해 데이터의 읽기 속도를 높이는 기능이다.**





### 인덱스를 사용하는 경우

- 대량의 데이터를 검색하는 경우: 대량의 데이터를 전체 스캔하는 것은 매우 느리고 부하가 발생하기 때문에 인덱스를 사용해 검색하는 것이 효율적
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- 정렬된 결과를 출력하는 경우
- 조인 연산을 수행하는 경우: 인덱스를 생성하여 조인 대상 테이블의 데이터를 빠르게 검색할 수 있음
- 유니크한 값을 가져오는 경우: 인덱스는 유니크한 값을 가지고 있는 필드에 대해 중복되지 않은 값을 빠르게 검색 가능
- 검색 빈도가 높은 경우





### 인덱스의 구분

- 역할 별 구분

  - primary key: 식별자 (null값 불허, 중복 불허)
  - secondary key: primary key 제외한 모든 인덱스는 보조 인덱스로 분류. 추가적인 검색 성능 제공.

  ```sql
  CREATE TABLE students (
      student_id INT PRIMARY KEY,
      name VARCHAR(100),
      age INT,
      INDEX (name),
      INDEX (age)
  );
  ```

  

- 데이터 저장 방식 별 구분

  - B-Tree 인덱스: 99%가 B-Tree 알고리즘을 사용하며, 아주 일반적인 인덱스
  - Hash 인덱스: 메모리 기반의 데이터베이스 또는 특수한 
  - Fractal-Tree 인덱스: B-Tree의 단점 보완하기 위한 알고리즘

- 데이터 중복 여부 별 구분

  - Unique / Non-Unique index (같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지 의미)
  - optimizer에게는 아주 중요한 정보. equal 조회 시 1건만 리턴되며 더이상 찾지 않아도 된다는 것을 의미

- 클러스터링 인덱스

  - 일반적인 인덱스: 레코드를 저장하는 시점에 임의의 빈 공간에 저장
  - 클러스터링 인덱스: 인덱스 키 값 순서대로 데이터를 저장해 insert는 느리나, 클러스터링 키 값을 대상으로 범위 검색을 수행하면 랜덤 액세스 없이 레코드를 읽어 아주 빠르게 레인지 스캔 가능.

---



## 인덱스의 종류

### 📎  B-Tree 인덱스

`B-Tree`는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘이다. 또한 가장 범용적인 목적으로 사용되는 인덱스 알고리즘으로, B-Tree 이외에도 `B+-Tree` 와 `B*-Tree`가 사용된다.

`B-Tree`의 `B`는 Binary가 아닌 Balanced를 의미한다.

![images_emplam27_post_64290106-d927-4a82-9e08-8e52783c7dd3_DB 인덱스](https://github.com/user-attachments/assets/e4f00ea7-01d9-49da-91e2-443bdb204a68)


- 위와 같은 구조가 `B-Tree`

- `B-Tree`는 데이터베이스 인덱싱에 사용되는 트리 구조로, 모든 노드가 키와 포인터를 포함하고 있으며, 각 노드는 **정렬된 상태를 유지**하며, 데이터는 리프 노드와 중간 노드에 저장될 수 있다.

- 루트 노드는 `0x01`이며, 중간 노드이자 루트 노드의 자식들은 `0x02`, `0x03`, `0x04`다.

- 리프노드는 실제 데이터를 가리키는 포인터를 가지고 있으며, 데이터가 있는 위치를 직접 가리킨다.

> 📌 **B+-Tree**
>
> ![images_emplam27_post_bcbce100-d475-4cda-aebe-946d1813949c_B플러스 트리 기본 형태](https://github.com/user-attachments/assets/0bddcd8c-25c7-4c1f-ae08-185b7aaf7e95)
>
> - 위와 같은 구조가 `B+-Tree`로 대용량 데이터베이스에서 효율적인 범위 검색과 순차 접근을 위해 사용된다.
> - `B+-Tree`는 `B-Tree`의 변형된 형태로, 리프 노드에만 실제 데이터가 저장되며, 리프 노드들이 연결 리스트 형태로 연결되어 있다.
>   - 리프 노드가 연결 리스트로 연결되어 있어, 순차적으로 저장되어 있다
>   - 범위 검색(Range Search)이나 순차 검색(Sequential Search)에 효율적
>   - O(𝑙𝑜𝑔𝑛)의 시간 복잡도를 가짐
> - `B-Tree`는 옆에 있는 리프노드를 검사할 때, 다시 루트 노드부터 검사해야 한다면, `B+-Tree`는 리프노드에서 선형 검사를 수행할 수 있어 시간 복잡도가 굉장히 줄어든다.
> - 리프 노드에만 데이터를 저장하고, 중간 노드에는 키 값과 포인터만 저장한다.



#### 추가

- 테이블에 레코드를 추가하는 비용이 1이라면, 키를 추가하는 비용은 1~1.5다.
- 컬렉션에 3개의 인덱스가 있다면 5.5(1.5 * 3 + 1)정도의 비용이 든다는 것.
- 메모리와 CPU에서 처리하는 것이 아니라 디스크로부터 인덱스 페이지를 읽어오는데 걸리는 시간이다.



#### 검색

- 트리 검색(Tree traversal): B-Tree의 루트 노드 → 브랜치 노드 → 최종 리프 노드까지 비교하며 인덱스를 검색하는 작업
- 검색은 조회 쿼리에서만 하는게 아니라 UPDATE, DELETE 시에도 먼저 해야 하기 때문에, 이 때에도 빠른 검색이 가능하게 한다.
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 앞부분 일치만 사용할 수 있고, 부등호 비교에는 사용할 수 없다.



#### 변경

- 먼저 키 값을 찾아 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.
- 키 값의 변경 때문에  B-Tree 인덱스 키값의 삭제와 추가 작업은 위에 명시된 삭제, 추가 작업을 각각 진행한다고 보면 된다.



#### 삭제

- 삭제된 인덱스에 마크한 뒤 방치되거나 재활용된다.
- 내부적으로 캐시를 가지고 있기 때문에 데이터 마크를 위한 작업은 사용자 요청과는 비동기로 처리된다.



#### B-Tree 인덱스의 가용성 및 효율성

- B-Tree 인덱스는 왼쪽에서 오른쪽으로 정렬된 구조를 가지고 있어, 이진 탐색을 가능하게 하여 특정 조건에 맞는 데이터를 빠르게 찾을 수 있다.

- 검색 조건이 인덱스의 첫 번째 컬럼을 포함하지 않으면 인덱스를 사용할 수 없다. 첫 번째 인덱스를 알아야 하고 그 다음 인덱스를 사용할 수 있다.

- B-Tree 인덱스를 사용할 수 있는 경우

  - 동등비교 : 첫 번째 인덱스부터 동등한 형태로 비교되는 경우

    ```sql
    SELECT * FROM employees WHERE department = 'Sales';
    ```

  - 크다/작다 비교 

    ```sql
    SELECT * FROM employees WHERE salary > 50000;
    ```

  - 문자열 패턴 좌측 일치

    ```sql
    SELECT * FROM employees WHERE name LIKE 'John%';
    ```

    

- B-Tree 인덱스를 사용할 수 없는 경우

  - Not-Equal 연산자(<>, NOT IN, NOT BETWEEN, IS NOT NULL)를 사용하는 경우: 이러한 비교가 인덱스의 정렬된 순서를 무시하기 때문

    ```sql
    SELECT * FROM employees WHERE department != 'Sales';
    ```

  - prefix 일치가 아닌 문자열 패턴 검색(LIKE ''%??')

    ```sql
    SELECT * FROM employees WHERE name LIKE '%ohn%';
    ```

  - 내장 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우

    ```sql
    WHERE SUBSTRING(column, 1, 1) = 'X'
    WHERE DAYOFMONTH(column) = 1
    ```

  - 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)

    ```sql
    WHERE char_column = 10
    ```

  - 문자열 데이터 타입의 콜레이션이 다른 경우

    ```sql
    WHERE utf8_bin_char_column = euckr_bin_char_column



---



### 📎 해시(Hash) 인덱스

해시 인덱스는 B-Tree만큼 범용적이지 않지만 고유의 특성과 용도를 지닌 인덱스 가운데 하나다. 주로 **메모리 기반**의 테이블에서 사용된다.

![다운로드](https://github.com/user-attachments/assets/de25e44b-573d-4818-8ea3-e735ebb3fb82)


- 데이터=컬럼의 값, 데이터의 위치를 (Key, Value)로 사용해 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현
- 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원
- 가장 큰 장점은 실제 키값과는 관계없이 인덱스 크기가 작고 검색이 빠름
  - 트리 형태의 구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐서 키값 검색
  - 원래의 키값을 저장하는 것이 아니라 해시 함수의 결과(일반적으로 단순 숫자)를 저장하므로 키 칼럼의 값이 아무리 길어도 실제 인덱스에 저장되는 값은 4~8바이트 수준으로, B-Tree 인덱스보다 상당히 크기가 작음
- 해시 인덱스는 `등호(=) 연산`에는 최적화돼 있음
- 부등호 연산(>, <), 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용할 수 없음
  - 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성함
  - 키값 자체가 변환되어 저장되기 때문에 범위를 검색하거나 원본값 기준으로 정렬할 수 없음

일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현돼 있으며 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않는다는 특징이 있다. 해시 인덱스 알고리즘은 테이블의 인덱스뿐 아니라 InnoDB의 버퍼 풀에서 빠른 레코드 검색을 위한 `Adaptive Hash Index`로 사용되기도 하고, 오라클과 같은 DBMS에서는 `조인`에 사용되기도 한다.



#### 해시 인덱스의 가용성 및 효율성

- 해시 인덱스를 사용하는 경우

  - 작업 범위 제한 조건으로 해시 인덱스를 사용하는 쿼리

    ```sql
    SELECT * FROM tb_hash WHERE column='검색어';
    SELECT * FROM tb_hash WHERE column <=> '검색어'; -- 두 값이 같거나 둘 다 Null일 경우 True
    SELECT * FROM tb_hash WHERE column IN ('검색어1', '검색어2');
    SELECT * FROM tb_hash WHERE column IS NULL;
    SELECT * FROM tb_hash WHERE column IS NOT NULL;
    ```

- 해시 인덱스를 전혀 사용하지 못하는 경어

  ```sql
  SELECT * FROM tb_hash WHERE column >= '검색어';
  SELECT * FROM tb_hash WHERE column BETWEEN 10 AND 12;
  SELECT * FROM tb_hash WHERE column LIKE '검색어%';
  SELECT * FROM tb_hash WHERE column <> '검색어'; -- !=
  ```

  

  - 다중 칼럼으로 생성된 해시 인덱스에서도 모든 칼럼이 동등 조건으로 비교되는 경우에만 사용 가능

## 



### 📎 R-Tree 인덱스

MySQL의 공간 인덱스(Spatial Index)는 `R-tree` 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다.

- 각 도형의 포함 관계를 이용해 만들어진 인덱스

  - Contains() 또는 Intersect() 등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용할 수 있음

    ```sql
    SELECT * FROM tb_location
    WHERE CONTAINS(px, 사각상자); -- 공간 좌표 px가 사각 상자에 포함되는지 비교
    ```

    

- 기본적인 내부 메커니즘은 B-Tree와 흡사하다

  - B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라값
  - R-Tree는 2차원의 공간 개념 값이다
  - Rectangle의 `R`과 B-Tree의 `Tree`를 섞어서 `R-Tree`라는 이름을 붙임

---



### 📎 Fractal-Tree 인덱스

Fractal-Tree 인덱스는 B-Tree와 B+-Tree의 성능을 향상시키기 위해 개발된 데이터 구조>로, 특히 대용량 데이터베이스와 높은 쓰기 작업이 많을 때 효율적이다. 이 인덱스는 데이터 삽입 및 삭제 시의 성능을 크게 향상시키기 위해 설계되었다.

- 성능 최적화: 쓰기 성능이 가장 우수하며, 읽기 성능도 우수해 매우 큰 데이터 세트에 적합함
- 배치 삽입: 데이터가 삽입될 때마다 즉시 디스크에 기록하지 않고, 메모리 내의 버퍼에 저장해 두었다가 한 번에 디스크에 기록함. 이를 통해 디스크 I/O를 최소화 함.
- 병렬 처리
- 자체 균형 유지: B-Tree와 마찬가지로 Fractal-Tree 인덱스도 자동으로 균형을 유지하여 검색, 삽입, 삭제 연산의 시간 복잡도를 O(log n)으로 유지함
- 대용량 데이터베이스, 로그 관리 시스템, 분산 데이터 저장에 적합함

---





### 📎 전문 검색(Full Text Search) 인덱스

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text) 검색이다. 문서의 키워드를 인덱싱하는 기법에 따라 크게 구분자(Stopword)와 N-그램으로 나눠서 생각해 볼 수 있다.

- 구분자(Stopword) 기법
  - 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장 기호, 그리고 사용자가 정의한 문자열을 구분자로 등록
  - 이렇게 등록된 구분자를 이용해 키워드를 분석해 내고, 결과 단어를 인덱스로 생성해 검색에 이용
  - 일반적으로 공백이나 쉼표 또는 한국어의 조사 등을 구분자로 많이 사용
- N-그램(n-Gram) 기법
  - 각 국가의 언어는 띄어쓰기가 전혀 없다거나 문장 기호가 전혀 다른 경우가 많음 
  - 지정된 규칙이 없는 전문도 분석 및 검색을 가능하게 하는 방법으로, 본문을 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법
  - 구분자에 의한 방법보다는 인덱싱 알고리즘이 복잡하고, 만들어진 인덱스의 크기도 상당히 큰 편





## 참고

https://velog.io/@kwontae1313/%EC%9D%B8%EB%8D%B1%EC%8A%A4Index%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

https://mangkyu.tistory.com/96

https://ittrue.tistory.com/331

https://thefif19wlsvy.tistory.com/26

https://yenilee.github.io/2021/09/16/b-tree.html

https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree

https://velog.io/@kth121211/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-%EB%B0%8F-%EC%9E%A5%EB%8B%A8%EC%A0%90

https://velog.io/@sem/DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0-B-Tree
