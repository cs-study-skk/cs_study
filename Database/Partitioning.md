# 파티셔닝(Partitioning)

파티션이란 MySQL 서버의 입장에서 데이터를 별도의 테이블로 분리해서 저장하지만 사용자 입장에서는 여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는 솔루션이다. 일반적으로 DBMS의 파티션은 **하나의 서버에서 테이블을 분산하는 것**이며, 원격 서버 간에 분산을 지원하는 것은 아니다.

- 테이블 또는 인덱스 테이블을 파티션(Partition) 단위로 나누어 저장하는 것을 말함
- 파티셔닝 기법을 통해 소프트웨어적으로 데이터베이스를 분산 처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 됨



## 📎 파티셔닝의 목적

테이블의 데이터가 많아진다고 해서 무조건 파티션을 적용하는 것이 효율적인 것은 아니다. 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나, 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이 파티션이 필요한 대표적인 예라고 할 수 있다.

- 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하를 가져옴
- VLDB(Very Large DBMS)와 같이 하나의 DBMS에 너무 큰 테이블이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 됨
- 이런 이슈를 해결하기 위한 방법으로 테이블을 `파티션(partition)`이라는 작은 단위로 나누어 관리하는 `파티셔닝(Partitioning)` 기법 이 나타나게 되었음



### 파티셔닝의 장점

- 성능 향상: 쿼리가 특정 파티션만 접근하도록 제한해 불필요한 데이터 접근을 줄임
  - 특정 DML과 쿼리의 성능을 향상 시키며, 대용량 데이터를 쓰는 환경에서 효율적임
  - Full Scan에서 데이터 접근의 범위를 줄여 성능 향상을 가져옴
  - 많은 INSERT가 있는 OLTP 시스템에서 INSERT 작업을 작은 단위인 Partition들로 분산시켜 경험을 줄임
- 관리 용이성: 큰 테이블을 제거하고, 각 파티션을 독립적으로 백업하거나 복구해 데이터베이스 관리가 용이해짐
- 가용성 향상: 일부 파티션에 문제가 생겨도 전체 데이터베이스가 영향을 받지 않도록 함
  - 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터의 가용성이 향상됨
  - 테이블의 파티션 단위로 디스크 I/O을 분산하여 경합을 줄이기 때문에 UPDATE 성능을 향상시킴
- 데이터 유지 관리: 파티션 단위로 데이터 보존 정책을 적용할 수 있음



### 파티셔닝의 단점

- 복잡성 증가: 파티셔닝 전략을 설계하고 구현하는 데 많은 노력이 필요하며, 관리가 복잡하다.
- 성능 저하의 위험: 부적절한 파티셔닝 키 선택은 성능을 오히려 저하시킴. 데이터가 특정 파티션에 집중되어 있으면 그 파티션에서 병목 현상이 발생할 수 있음
- 추가적인 저장 공간 필요
- 일관성 유지: 서버 고장 시 데이터 무결성에 취약
- 테이블 간 JOIN에 대한 비용이 증가
- 테이블과 인덱스를 별도로 파티셔닝할 수 없어, 테이블과 인덱스를 같이 파티셔닝해야 함





## 📎 DB 파티셔닝의 종류



### 수평(Horizontal) 파티셔닝

데이터베이스의 테이블을 행(row)을 기준으로 테이블을 분할하는 형태다.

<img width="606" alt="다운로드 (2)" src="https://github.com/user-attachments/assets/e39a4f53-c2d9-4bbd-890f-732d5d2e1501">


- 성능, 가용성을 위해 KEY 기반으로 여러 곳에 분산 저장
- 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미함
- 보통 수평 분할을 한다고 했을 때는 **하나의 데이터베이스 안에서 이루어지는 경우**를 지칭함

- 장점

  - 데이터의 개수를 기준으로 나누어 파티셔닝함
  - 성능 향상: 데이터의 개수가 작아짐에 따라 인덱스의 개수도 작아짐 → 성능이 자연스럽게 향상됨
  - 확장성: 새로운 서버를 추가하면 더 많은 데이터 처리 가능
  - 보안: 각 파티션 별로 권한 따로 설정 가능
  - 유지보수 쉬움: 작은 파티션 관리가 편함

- 단점

  - 서버 간의 연결 과정이 많아짐
  - 쿼리 복잡성: 데이터를 찾는 과정이 기존보다 복잡해져 지연 시간(latency)이 늘어남
  - 데이터 무결성 관리: 데이터 일관성 유지에 관리 어려움
  - 데이터 중복: 특정 작업 때문에 데이터가 중복될 수 있음
  - 부하 균형: 파티션 간에 부하를 균등하게 분산시키기 어려움

  

  

### 수직(Vertical) 파티셔닝

데이터베이스의 테이블을 열(Column)을 기준으로 분할하는 형태다.

<img width="640" alt="다운로드 (1)" src="https://github.com/user-attachments/assets/93349ab4-5473-46da-8932-aca03d99eeb4">


만약 한 테이블에 수많은 컬럼이 존재한다면 디스크의 여러 블록에 데이터가 저장되므로 I/O 성능 저하를 불러올 수 있다. 이렇게 컬럼이 많아지면 로우 체이닝과 로우 마이그레이션이 많아져서 성능이 저하된다.



> **로우 체이닝(Row Chaining)**
>
> 길이가 너무 커서 하나의 블록에 저장되지 못하고 다수의 블록에 나누어 저장



> **로우 마이그레이션(Row Migration)**
>
> 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록의 빈 공간에 저장



- 정규화도 수직 파티셔닝과 관련된 과정이라고 할 수 있지만, 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정임
- RDB에서 제3정규화와 같은 개념임
- 장점
  - 성능 개선: 자주 사용하는 컬럼 등을 분리해 성능을 향상시킬 수 있음
  - 한 테이블을 SELECT하면 결국 모든 컬럼을 메모리에 올리게 되므로 필요없는 컬럼까지 올라가서 한 번에 읽을 수 있는 ROW가 줄어듦. 이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있음.
  - 쉬운 유지보수: 같은 타입의 데이터가 저장되기 때문에 저장 시 데이터의 압축률을 높일 수 있음
  - 보안 강화: 중요한 열을 따로 저장해 더 안전함
- 단점
  - 쿼리 복잡성: 데이터를 찾는 과정이 기존보다 복잡하고, 지연 시간이 증가함
  - 중복 데이터: 여러 테이블에 동일한 정보가 중복 저장될 수 있음
  - 확장성 제한: 열 기반으로 분할되어 새로운 데이터 추가가 어려울 수 있음



### 수평 분할 vs. 수직 분할

- 테이블의 컬럼 개수와 데이터 양을 종합적으로 판단하여 양에 따른 대용량 테이블인지 판단
  - **컬럼 개수**에 따른 것이라면, 트랜잭션의 특성에 따라 테이블을 1:1 형태로 분리하는 **수직분할**을 하면 된다.
  - **데이터 양**에 따른 것이라면, 적절한 파티션을 선택하고 여러 개의 물리적 스페이스로 저장하는 **수평분할**을 하면 된다.

- 결론은 **Row 단위의 트랜잭션 (수평분할)** 인지 **컬럼 단위의 트랜잭션 (수직분할)** 인지 판단하자.

---

### 분할 키 기준 분할 기법

파티션의 종류로는 범위(Range), 목록(List), 해시(Hash), 합성(Composite) 파티션이 있다.



<img width="640" alt="다운로드 (3)" src="https://github.com/user-attachments/assets/56086070-3a18-46e0-869b-2414894e7725">




#### 범위 파티셔닝(Range Partitioning)

특정 범위를 기준으로 데이터를 분할하며, 가장 보편적으로 이용되는 방법이다.

- 연속적인 숫자나 날짜, 범위 등을 기준으로 파티션을 나눔
- 분할 키 값이 범위 내에 있는지 여부로 구분
- 데이터가 균등하게 나누어져서 비슷한 성능 개선을 보장
- 우편 번호, 날짜 등의 데이터에 적합함

```sql
CREATE TABLE sales (
    sale_id INT,
    sale_date DATE,
    amount DECIMAL(10, 2)
)
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p0 VALUES LESS THAN (2021),
    PARTITION p1 VALUES LESS THAN (2022),
    PARTITION p2 VALUES LESS THAN (2023)
);
```



#### 리스트 파티셔닝(List Partitioning)

특정 값의 목록을 기준으로 데이터를 분할한다.

- 주로 PK나 고정된 카테고리나 그룹을 기준으로 나눌 때 사용
- 분포도가 비슷하며, 많은 SQL에서 해당 칼럼의 조건이 많이 들어오는 경우 유용함
- 예를 들어, Country 라는 컬럼의 값이 Iceland , Norway , Sweden , Finland , Denmark 중 하나에 있는 행을 빼낼 때 북유럽 국가 파티션을 구축 할 수 있다.

```sql
CREATE TABLE employees (
    emp_id INT,
    department VARCHAR(50)
)
PARTITION BY LIST (department) (
    PARTITION p_sales VALUES IN ('Sales'),
    PARTITION p_hr VALUES IN ('HR'),
    PARTITION p_it VALUES IN ('IT')
);
```



#### 해시 파티셔닝(Hash Partitioning)

해시 함수의 결과를 기준으로 데이터를 분할한다.

- 데이터가 균등하게 분포되도록 할 때 유용
- 데이터의 관리보다는 성능 향상에 목적을 둔다: 특정한 데이터가 어느 해시 파티션에 있는지 판단하기 어려움
- 예) 4개의 파티션으로 분할하는 경우 해시 함수는 0~3의 정수를 돌려줌

```sql
CREATE TABLE orders (
    order_id INT,
    customer_id INT
)
PARTITION BY HASH(customer_id) PARTITIONS 4;
```



#### 조합 파티셔닝(Composite Partitioning)

여러 파티셔닝 방법을 결합하여 데이터를 분할한다.

- 파티션의 sub-partitioning으로 위의 분할들을 결합하는 것을 의미함
- 큰 파티션에 대한 I/O 요청을 여러 파티션으로 분산할 수 있음
- 예를 들어, 범위 파티셔닝과 해시 파티셔닝을 결합할 수 있음

```sql
CREATE TABLE transactions (
    trans_id INT,
    trans_date DATE,
    amount DECIMAL(10, 2)
)
PARTITION BY RANGE (YEAR(trans_date)) SUBPARTITION BY HASH(amount) SUBPARTITIONS 4 (
    PARTITION p0 VALUES LESS THAN (2021),
    PARTITION p1 VALUES LESS THAN (2022),
    PARTITION p2 VALUES LESS THAN (2023)
);
```



#### 라운드 로빈 파티셔닝(Round-Robin Partitioning)

라운드 로빈은 파티션에 행의 고른 분포를 원할 때 사용한다.

<img width="640" alt="다운로드 (4)" src="https://github.com/user-attachments/assets/84356dee-870d-4c09-8067-2a71b585f599">

![다운로드](https://github.com/user-attachments/assets/f23431d7-db2d-4103-bf78-dafcbaaa3275)



- 해시분할과 달리 분할 칼럼을 명시할 필요가 없다.

- **회전하면서 새로운 행이 파티션에 할당된다.**

- 하나의 중앙처리장치를 임의의 프로세스가 종료될 때까지 차지하는 것이 아니라, **여러 프로세스들이 중앙처리장치를 조금씩 돌아가며 할당받아 실행되는 방식**으로, 리눅스를 포함한 대부분의 시스템에서 사용하는 방식

  











## 참고

https://yunamom.tistory.com/291

https://velog.io/@kyeun95/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9DPartitioning%EC%9D%B4%EB%9E%80

https://gmlwjd9405.github.io/2018/09/24/db-partitioning.html
